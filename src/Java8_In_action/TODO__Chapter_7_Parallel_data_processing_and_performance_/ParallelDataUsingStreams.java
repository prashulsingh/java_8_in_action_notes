package Java8_In_action.TODO__Chapter_7_Parallel_data_processing_and_performance_;

import org.omg.SendingContext.RunTime;

import java.sql.Time;
import java.time.Instant;
import java.time.LocalTime;
import java.util.Date;
import java.util.Locale;
import java.util.Optional;
import java.util.OptionalInt;
import java.util.stream.IntStream;

public class ParallelDataUsingStreams {

    public static void main(String[] args) {
        /*The difference is that the Stream is internally divided into multiple chunks. As a result, the reduction
         operation can work on the various chunks independently and in parallel
        . Internally, a boolean flag is set to signal that you want to run in parallel all the operations that
         follow the invocation to parallel.
        stream.parallel()
                .filter(...)
      .sequential()
                .map(...)
      .parallel()
                .reduce();
        by default has as many threads as you have processors, as returned by Runtime.getRuntime().availableProcessors().
         */
        System.out.println(Runtime.getRuntime().availableProcessors()); //---> 8 output
        // 8 threads will be there by default
        /*7.1.2. Measuring stream performance, sum of n elements */

        Instant now = Instant.now();
        int sum = 0;
        int n = Integer.MAX_VALUE;
        for( int i = 0 ; i < n; i++ )
                sum++;
        Instant then = Instant.now();

        //Iterative 7
        System.out.println("Iterative" + (then.toEpochMilli()-now.toEpochMilli()));

        now = Instant.now();
        IntStream.rangeClosed(0, Integer.MAX_VALUE).reduce(0,(integer, integer2) -> integer + 1);
        then = Instant.now();

        //Sequential stream 213
        System.out.println("Sequential stream" + (then.toEpochMilli()-now.toEpochMilli()));

        now = Instant.now();
        IntStream.rangeClosed(0, Integer.MAX_VALUE).parallel().reduce(0,(integer, integer2) -> integer+1 );
        then = Instant.now();

        // Parallel range closed stream 101
        System.out.println("Parallel range closed stream" + (then.toEpochMilli()-now.toEpochMilli()));

        now = Instant.now();
        IntStream.range(0, Integer.MAX_VALUE).parallel().reduce(0,(integer, integer2) -> integer+1 );
        then = Instant.now();

        // Parallel stream2527
        System.out.println("Parallel stream" + (then.toEpochMilli()-now.toEpochMilli()));


        //7.1.3. Using parallel streams correctly

        /*
        The main cause of errors generated by misuse of parallel streams is
        the use of algorithms that mutate some shared state.

        Some operations naturally perform worse on a parallel stream than on a sequential stream.
        In particular, operations such as limit and findFirst that rely on the order of the elements are expensive in
        a parallel stream. For example, findAny will perform better than findFirst because it isnâ€™t constrained to operate in the encounter order.
        Take into account how well the data structure underlying the stream decomposes. For instance, an ArrayList can be split much more efficiently than a LinkedList,
         */


    //        7.2. THE FORK/JOIN FRAMEWORK
        

    }
}
